<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1">

</head>

<body>
  <script>
    class YfPromise {
      constructor(handle) {
        this["[[PromiseState]]"] = "pending";
        this["[[PromiseResult]]"] = undefined;

        // then任务对列
        this.resolveQueue = [];
        this.rejectQueue = [];

        // 执行函数 handle
        handle(this.#resolve.bind(this), this.#reject.bind(this));
      }

      #resolve(val) {
        this["[[PromiseState]]"] = "fulfilled";
        this["[[PromiseResult]]"] = val;

        // 执行的位置 迁移到 这里
        const run = () => {
          let cb;
          while (cb = this.resolveQueue.shift()) {
            cb && cb(val);
          }
        };
        setTimeout(run)
      }

      #reject(err) {
        this["[[PromiseState]]"] = "rejected";
        this["[[PromiseResult]]"] = err;

        // 执行的位置 迁移到 这里
        const run = () => {
          // this.rejectFn(err);
          let cb;
          while ((cb = this.rejectQueue.shift())) {
            cb && cb(err);
          }
        };
        setTimeout(run)
      }

      then(onResolved, onRejected) {
        //   返回一个 YfPromise 来支持 then
        return new YfPromise((reslove, reject) => {
          // 封装 onResolved onRejected

          // 成功
          let resolveFn = (val) => {
            let res = onResolved && onResolved(val);
            reslove(res); // 返回用于下一个then使用
          };
          this.resolveQueue.push(resolveFn);
          // 失败
          let rejectFn = (err) => {
            onRejected && onRejected(val);
            reject(err); // 返回用于下一个then使用
          };
          this.rejectQueue.push(resolveFn);
        });
      }
    }

    const wang = new YfPromise((res) => {
      setTimeout(()=>{
        res('yunfei')
      },2000)
    }).then((res) => {
      console.log(res)
      return 'wang'
    }).then(res => {
      console.log(res)
    })
  </script>
</body>

</html>